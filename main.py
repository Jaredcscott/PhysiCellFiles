from numpy.random import randint
from numpy.random import rand
import xml.etree.ElementTree as ET
import subprocess
from pathlib import Path
from loader.pyMCDS import pyMCDS
import sys
from contextlib import redirect_stdout
from time import time

# Steps:
# Expects a pre-compiled physicell implementation, with a project ready to run
# Extract the microenvironment setup from the xml:
# Extract relevant variables from the microenvironment:
#   physical values are inherent to the chemical species, so you'll need to look that up
#   we can play with the initial condition and the dirichlet boundary condition (edges)
#   generate random bits within the size constraints of the extracted variables
#   convert bits into floats/integers to input into the simulation
#   plug them into the simulation
#   run the simulation
#   evaluate the volume of the cells produced during the simulation
#   select parents
#   apply crossover
#   apply mutation
#   repeat from "convert" for each generation I would like to produce

# TODO: Save the final svgs from each generation's best solution to visualize the process of optimizing
# TODO: Log output from this console
# TODO: Update the way I'm evaluating the bests so the output is correct. Currently, the generation is not tracked.

# Note: for some reason, physicell takes longer to run these small simulations if I increase the threadcount variable
# in the PhysiCell setting file. I wonder if I just tell it to use a single thread, and do some multithreading in here
# at the point where I run the fitness simulations if that would increase my evaluation speed for each generation.

# Reading PhysiCell settings we can modify
def readSettings(filepath):
    """
    Reads the PhysiCell settings file and parses the variables from the microenvironment into a dictionary.
    :param filepath: path to the xml file
    :return: a dictionary in the form { name: {units:*,ID:*,initial_condition:*,dirichlet_boundary_condition:*}}
    """
    env_variables = {}
    tree = ET.parse(filepath)
    root = tree.getroot()
    for var in root[5].findall('variable'):
        name = var.get('name')
        units = var.get('units')
        ID = var.get('ID')
        initial_condition = float(var.find('initial_condition').text)
        dirichlet_boundary_condition = float(var.find('Dirichlet_boundary_condition').text)
        env_variables.update({name: {"units": units,
                                     "ID": ID,
                                     "initial_condition": initial_condition,
                                     "dirichlet_boundary_condition": dirichlet_boundary_condition}})

    return env_variables

def saveXMLsettings(filepath, settings):
    """
    Opens PhysiCell_settings.xml, compares changes to the settings dictionary, updates values that have changed,
    and overwrites the previous settings.
    :param filepath: path to PhysiCell_settings.xml
    :param settings: settings dict generated by a previous call to readSettings()
    """
    tree = ET.parse(filepath)
    root = tree.getroot()
    for var in root[5].findall('variable'):
        if (name := var.get('name')) in settings:
            var.find('initial_condition').text = str(settings[name]['initial_condition'])
            var.find('Dirichlet_boundary_condition').text = str(settings[name]['dirichlet_boundary_condition'])
    tree.write(f'{filepath}')


def fitnessEvaluation(physicellPath):
    """
    Runs PhysiCell silently. PhysiCell will take whatever settings are in its XML and run the simulation. The python
    loader module is then used to asses the total volume of cells after the simulation.
    :param: physicellPath
    :return: total cell volume
    """
    with open('logs.txt', 'a') as f:
        with redirect_stdout(f):
            subprocess.run(physicellPath / 'cultured_meat.exe', cwd=physicellPath, stdout=f)
            mcds = pyMCDS('final.xml', physicellPath / 'output')
            return sum(mcds.data['discrete_cells']['total_volume'])

# objective function
def objective(x):
    return x[0]**2.0 + x[1]**2.0

# decode bitstring to numbers
def decode(bounds, n_bits, bitstring):
    decoded = []
    largest = 2**n_bits
    for i in range(len(bounds)):
        # extract the substring
        start, end = i * n_bits, (i * n_bits)+n_bits
        substring = bitstring[start:end]
        # convert bitstring to a string of chars
        chars = ''.join(str(s) for s in substring)
        # convert string to integer
        integer = int(chars, 2)

        # if it needs to be scaled, scale it
        if largest != bounds[i][1] or bounds[i][0] != 0:
            # scale integer to desired range
            value = bounds[i][0] + (integer/largest) * (bounds[i][1] - bounds[i][0])
            # if it divided evenly, make it an int
            if value % 1 < 0.00000001:
                value = int(value)
        else:
            # if the scale is already correct, don't convert the values to floats
            value = integer

        # store
        decoded.append(value)
    return decoded

# tournament selection
def selection(pop, scores, k=3):
    # first random selection
    selection_ix = randint(len(pop))
    for ix in randint(0, len(pop), k-1):
        # check if better (e.g. perform a tournament)
        if scores[ix] > scores[selection_ix]:
            selection_ix = ix
    return pop[selection_ix]

# best selection, less efficient, but better for a small sample size because it
# only returns the best parents
def bestSelection(pop, scores, num_parents=3):
    """
    Yields the top performers repeatedly.
    :param pop: population to evaluate
    :param scores: the scores associated with the population
    :param num_parents: the number of top performers to iterate through
    :return: one of the parents
    """
    paired = [*zip(pop,scores)]
    # print(f"pop and scores: {paired}")
    paired.sort(key=lambda x: x[1], reverse=True)
    # print(f"sorted: {paired}")
    def gen_bestSelection(i):
        index = i
        while True:
            yield paired[index][0]
            index += 1
            if index >= num_parents:
                index = 0
    return gen_bestSelection(0)


# crossover two parents to create two children
def crossover(p1, p2, r_cross):
    # children are copies of parents by default
    c1, c2 = p1.copy(), p2.copy()
    # check for recombination
    if rand() < r_cross:
        # print(f"performing crossover...")
        # select crossover point that is not on the end of the string
        pt = randint(1, len(p1)-2)
        # moving crossover point closer to begining of the float for more variability
        # pt = randint(1, len(p1)-(int(len(p1)/4)))
        # perform crossover
        c1 = p1[:pt] + p2[pt:]
        c2 = p2[:pt] + p1[pt:]
    return [c1, c2]

# mutation operator
def mutation(bitstring, r_mut):
    for i in range(len(bitstring)):
        # check for a mutation
        if rand() < r_mut:
            # flip the bit
            bitstring[i] = 1 - bitstring[i]

# genetic algorithm
def genetic_algorithm(objective, bounds, n_bits, n_iter, n_pop, r_cross, r_mut, physicellPath, num_parents=3):

    settingPath = physicellPath / 'config' / 'PhysiCell_settings.xml'
    outputPath = physicellPath / 'output'

    # initial population of random bitstring
    # pop = [randint(0, 2, n_bits*len(bounds)).tolist() for _ in range(n_pop)]
    pop = [randint(0, 2, n_bits*len(bounds)).tolist() for _ in range(n_pop)]
    print(f'initial random population: {pop[0]}', file=sys.stderr)


    # I need 2 numbers to throw into settings
    # pairs = [decode(bounds, n_bits, p) for p in pop]
    # decoded = [decode(bounds, n_bits, p) for p in pop]
    # print(f"pairs: {pairs}")
    # print(f"pairs: {decoded}")

    # # Set the first member of the population to the current best
    # settings = readSettings(settingPath)
    # settings['oxygen']['initial_condition'] = pairs[0][0]
    # settings['oxygen']['dirichlet_boundary_condition'] = pairs[0][1]
    # saveXMLsettings(settingPath, settings)
    # bestInputs = [pairs[0][0],pairs[0][1]]
    # best, best_eval = 0, objective(physicellPath)

    best = 0
    # bestInputs = decoded[0]
    bestInputs = None
    best_eval = - 1 * 2**64


    for generation in range(n_iter):
        # a generation will run n_pop tests
        print(f"Starting generation {generation}")
        # pairs = [decode(bounds, n_bits, p) for p in pop]
        pop_decoded = [decode(bounds, n_bits, p) for p in pop]
        startTime = time()


        # Run PhysiCell to evaluate all of the random pairs, updating best and best eval as we go
        i = 0
        generationScores = []

        # run fitness based off csv

        for index,arrangement in enumerate(pop_decoded):
            # populate csv
            with open(physicellPath / 'coords.csv', 'w') as f:
                coordinates = pop_decoded[index]
                # for coordinates in pop_decoded:
                    # separates coordinates into pairs, adds a 0 for the z coordinate, and builds the csv
                    # [print(str(coordinates[i:i + 2]).strip("[]") + ", 0, 3",file=f) for i in range(index * n_pop, index * n_pop + n_pop, 2)]
                [print(str(coordinates[i:i + 2]).strip("[]") + ", 0, 3",file=f) for i in range(0,len(coordinates),2)]

            # run fitness function for current arrangement
            current_eval = objective(physicellPath)
            generationScores.append(current_eval)

            print(f"    {index}: evaluation = {current_eval:.4f}, coordinates: {[tuple(coordinates[i:i + 2]) for i in range(0, len(coordinates), 2)]}")
            if current_eval > best_eval:
                best = index
                bestInputs = arrangement
                best_eval = current_eval

        # for initial,boundary in pairs:
        #     # print(f'i: {i}')
        #     # print(f"initial: {initial}")
        #     # print(f"boundary: {boundary}")
        #     settings = readSettings(settingPath)
        #     settings['oxygen']['initial_condition'] = initial
        #     settings['oxygen']['dirichlet_boundary_condition'] = boundary
        #
        #     saveXMLsettings(settingPath, settings)
        #     # evaluate fitness here
        #     current_eval = objective(physicellPath)
        #     generationScores.append(current_eval)
        #     print(f"    {i}: [initial = {initial:>7.4f}, boundary = {boundary:>7.4f}] evaluation = {current_eval:.4f}")
        #     if current_eval > best_eval:
        #         best = i
        #         bestInputs = [initial,boundary]
        #         best_eval = current_eval
        #         # print(f"New best found: {best_eval} in generation {generation}")
        #
        #     # best, best_eval = 0, objective(physicellPath)
        #     i += 1

        endTime = time()
        # print(f"Generation {generation} computed in {endTime - startTime:.4f} seconds, best = {best}: {pairs[best]}")
        print(f"Generation {generation} computed in {endTime - startTime:.4f} seconds, best = {best}: {pop_decoded[best]}")
        # Select parents in current generation
        # selected = [selection(pop, generationScores) for _ in range(n_pop)]
        bestParents = bestSelection(pop, generationScores, num_parents)
        # use this for the tournament selection
        # selected = [selection(pop, generationScores, num_parents) for _ in range(n_pop)]
        selected = [next(bestParents) for _ in range(n_pop)]
        print(f"Selected parents: {selected}")
        children = []
        for i in range(0, n_pop, 2):
            # get selected parents in pairs
            p1, p2 = selected[i], selected[i+1]
            # crossover and mutation
            for c in crossover(p1, p2, r_cross):
                # mutation
                mutation(c, r_mut)
                # store for next generation
                children.append(c)
        # replace population
        print(f"        children: {children}")
        pop = children

        # pop = [randint(0, 2, n_bits*len(bounds)).tolist() for _ in range(n_pop)]
        # pairs = [decode(bounds, n_bits, p) for p in pop]


        #Also: https://colab.research.google.com/


    # print(f"pairs: {pairs}")

    # keep track of best solution
    # best, best_eval = 0, objective(decode(bounds, n_bits, pop[0]))
    # # enumerate generations
    # for gen in range(n_iter):
    #     # decode population
    #     decoded = [decode(bounds, n_bits, p) for p in pop]
    #
    #     # print(f'decoded: {decoded}')
    #     # evaluate all candidates in the population
    #     scores = [objective(d) for d in decoded]
    #     # print(f'scores: {scores}')
    #     # check for new best solution
    #     for i in range(n_pop):
    #         if scores[i] < best_eval:
    #             best, best_eval = pop[i], scores[i]
    #             print(">%d, new best f(%s) = %f" % (gen,  decoded[i], scores[i]))
    #     # select parents
    #     selected = [selection(pop, scores) for _ in range(n_pop)]
    #     # print(f'selecting parents: {selected}')
    #     # create the next generation
    #     children = list()
    #     for i in range(0, n_pop, 2):
    #         # get selected parents in pairs
    #         p1, p2 = selected[i], selected[i+1]
    #         # crossover and mutation
    #         for c in crossover(p1, p2, r_cross):
    #             # mutation
    #             mutation(c, r_mut)
    #             # store for next generation
    #             children.append(c)
    #     # replace population
    #     pop = children

    return [best, best_eval, bestInputs]


physicellPath = Path('C:/Users/korle/Documents/0USU/Spring 2021/CS5890 AI and Clean Energy/PhysiCell_V.1.8.0/PhysiCell/')
# settingPath = physicellPath / 'config' / 'PhysiCell_settings.xml'
# outputPath = physicellPath / 'output'


# get settings
# settings = readSettings(settingPath)


# mcds = pyMCDS()
# settings['oxygen']['initial_condition'] = 38.0
# saveXMLsettings(settingPath, settings)
# sub = subprocess.run(physicellPath / 'heterogeneity.exe', cwd=physicellPath)

# number of feeder cells to place
feeders = 5
# each feeder will have an x and y coordinate, so the input will be 10 ints long

# define range for input
# bounds = [[-5.0, 5.0], [-5.0, 5.0]]

# bounds = [[0, 100], [0, 100]]
bounds = []
for feeder in range(feeders * 2):
    bounds += [[-256, 256]]

# print(bounds)

# define the total iterations
# n_iter = 100
n_iter = 2

# bits per variable
n_bits = 9

# define the population size
n_pop = 10

# crossover rate
r_cross = 0.9

# mutation rate
r_mut = 1.0 / (float(n_bits) * len(bounds))

# print("Testing population:")
# pop = [randint(0, 2, n_bits*len(bounds)).tolist() for _ in range(n_pop)]
# print(pop)
# print(f"len(pop) = {len(pop)}")
# print("decoding pop:")
# decoded = [decode(bounds, n_bits, p) for p in pop]
# print(decoded)
# print(f"len(decoded) = {len(decoded)}")
# with open('coords.csv', 'w') as f:
#     coords = []
#     for run in decoded:
#         [print(str(run[i:i + 2]).strip("[]") + ", 0",file=f) for i in range(0, len(run), 2)]
#         [print(str(run[i:i + 2]).strip("[]") + ", 0") for i in range(0, len(run), 2)]
#         print("do something...")
#         # print(coords)



# perform the genetic algorithm search
best, score, inputs = genetic_algorithm(fitnessEvaluation, bounds, n_bits, n_iter, n_pop, r_cross, r_mut, physicellPath)

print('Done!')
print(f'best inputs: {inputs}, best score: {score}, at index: {best}')
# decoded = decode(bounds, n_bits, best)
# print('f(%s) = %f' % (decoded, score))
